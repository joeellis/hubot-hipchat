// Generated by CoffeeScript 1.8.0
(function() {
  var Adapter, Connector, EnterMessage, HTTPS, HipChat, LeaveMessage, TextMessage, User, errmsg, inspect, promise, _ref,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  _ref = require("../../hubot"), Adapter = _ref.Adapter, TextMessage = _ref.TextMessage, EnterMessage = _ref.EnterMessage, LeaveMessage = _ref.LeaveMessage, User = _ref.User;

  HTTPS = require("https");

  inspect = require("util").inspect;

  Connector = require("./connector");

  promise = require("./promises");

  HipChat = (function(_super) {
    __extends(HipChat, _super);

    function HipChat(robot) {
      var reconnectTimer;
      HipChat.__super__.constructor.call(this, robot);
      this.logger = robot.logger;
      reconnectTimer = null;
    }

    HipChat.prototype.emote = function() {
      var envelope, strings;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      return this.send.apply(this, [envelope].concat(__slice.call(strings.map(function(str) {
        return "/me " + str;
      }))));
    };

    HipChat.prototype.send = function() {
      var envelope, room, str, strings, target_jid, user, _i, _len, _results;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      user = envelope.user, room = envelope.room;
      if (!user) {
        user = envelope;
      }
      target_jid = (user != null ? user.reply_to : void 0) || (user != null ? user.jid : void 0) || ((user != null ? typeof user.search === "function" ? user.search(/@/) : void 0 : void 0) >= 0 ? user : room);
      if (!target_jid) {
        return this.logger.error("ERROR: Not sure who to send to: envelope=" + (inspect(envelope)));
      }
      _results = [];
      for (_i = 0, _len = strings.length; _i < _len; _i++) {
        str = strings[_i];
        _results.push(this.connector.message(target_jid, str));
      }
      return _results;
    };

    HipChat.prototype.topic = function(envelope, message) {
      var room, target_jid, user;
      user = envelope.user, room = envelope.room;
      if (!user) {
        user = envelope;
      }
      target_jid = (user != null ? user.reply_to : void 0) || (user != null ? user.jid : void 0) || ((user != null ? typeof user.search === "function" ? user.search(/@/) : void 0 : void 0) >= 0 ? user : room);
      if (!target_jid) {
        return this.logger.error("ERROR: Not sure who to send to: envelope=" + (inspect(envelope)));
      }
      return this.connector.topic(target_jid, message);
    };

    HipChat.prototype.reply = function() {
      var envelope, str, strings, user, _i, _len, _results;
      envelope = arguments[0], strings = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      user = envelope.user ? envelope.user : envelope;
      _results = [];
      for (_i = 0, _len = strings.length; _i < _len; _i++) {
        str = strings[_i];
        _results.push(this.send(envelope, "@" + user.mention_name + " " + str));
      }
      return _results;
    };

    HipChat.prototype.waitAndReconnect = function() {
      var delay;
      if (!this.reconnectTimer) {
        delay = Math.round(Math.random() * (20 - 5) + 5);
        this.logger.info("Waiting " + delay + "s and then retrying...");
        return this.reconnectTimer = setTimeout((function(_this) {
          return function() {
            _this.logger.info("Attempting to reconnect...");
            delete _this.reconnectTimer;
            return _this.run();
          };
        })(this), delay * 1000);
      }
    };

    HipChat.prototype.run = function() {
      var connector, host, init;
      this.options = {
        jid: process.env.HUBOT_HIPCHAT_JID,
        password: process.env.HUBOT_HIPCHAT_PASSWORD,
        token: process.env.HUBOT_HIPCHAT_TOKEN || null,
        rooms: process.env.HUBOT_HIPCHAT_ROOMS || "All",
        rooms_blacklist: process.env.HUBOT_HIPCHAT_ROOMS_BLACKLIST || "",
        host: process.env.HUBOT_HIPCHAT_HOST || null,
        autojoin: process.env.HUBOT_HIPCHAT_JOIN_ROOMS_ON_INVITE !== "false",
        xmppDomain: process.env.HUBOT_HIPCHAT_XMPP_DOMAIN || null,
        reconnect: process.env.HUBOT_HIPCHAT_RECONNECT !== "false"
      };
      this.logger.debug("HipChat adapter options: " + (JSON.stringify(this.options)));
      connector = new Connector({
        jid: this.options.jid,
        password: this.options.password,
        host: this.options.host,
        logger: this.logger,
        xmppDomain: this.options.xmppDomain
      });
      host = this.options.host ? this.options.host : "hipchat.com";
      this.logger.info("Connecting HipChat adapter...");
      init = promise();
      connector.onDisconnect((function(_this) {
        return function() {
          _this.logger.info("Disconnected from " + host);
          if (_this.options.reconnect) {
            return _this.waitAndReconnect();
          }
        };
      })(this));
      connector.onError((function(_this) {
        return function() {
          _this.logger.error([].slice.call(arguments).map(inspect).join(", "));
          if (_this.options.reconnect) {
            return _this.waitAndReconnect();
          }
        };
      })(this));
      connector.onConnect((function(_this) {
        return function() {
          var changePresence, handleMessage, joinRoom, saveUsers;
          _this.logger.info("Connected to " + host + " as @" + connector.mention_name);
          _this.robot.name = connector.mention_name;
          _this.emit("connected");
          saveUsers = function(users) {
            var user, _i, _len, _results;
            _results = [];
            for (_i = 0, _len = users.length; _i < _len; _i++) {
              user = users[_i];
              user.id = _this.userIdFromJid(user.jid);
              _results.push(_this.robot.brain.userForId(user.id, user));
            }
            return _results;
          };
          joinRoom = function(jid) {
            var blacklisted_room_jids;
            blacklisted_room_jids = _this.options.rooms_blacklist.split(",");
            if (__indexOf.call(blacklisted_room_jids, jid) >= 0) {
              _this.logger.info("Not joining " + jid + " because it is blacklisted");
              return;
            }
            _this.logger.info("Joining " + jid);
            return connector.join(jid);
          };
          connector.getRoster(function(err, users, stanza) {
            if (err) {
              return init.reject(err);
            }
            return init.resolve(users);
          });
          init.done(function(users) {
            var room_jid, _i, _len, _ref1, _results;
            saveUsers(users);
            if (_this.options.rooms === "All" || _this.options.rooms === "@All") {
              return connector.getRooms(function(err, rooms, stanza) {
                var room, _i, _len, _results;
                if (rooms) {
                  _results = [];
                  for (_i = 0, _len = rooms.length; _i < _len; _i++) {
                    room = rooms[_i];
                    _results.push(joinRoom(room.jid));
                  }
                  return _results;
                } else {
                  return _this.logger.error("Can't list rooms: " + (errmsg(err)));
                }
              });
            } else {
              _ref1 = _this.options.rooms.split(",");
              _results = [];
              for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
                room_jid = _ref1[_i];
                _results.push(joinRoom(room_jid));
              }
              return _results;
            }
          }).fail(function(err) {
            if (err) {
              return _this.logger.error("Can't list users: " + (errmsg(err)));
            }
          });
          connector.onRosterChange(function(users) {
            return saveUsers(users);
          });
          handleMessage = function(opts) {
            return init.done(function() {
              var author, getAuthor, message, reply_to, room;
              getAuthor = opts.getAuthor, message = opts.message, reply_to = opts.reply_to, room = opts.room;
              author = getAuthor() || {};
              author.reply_to = reply_to;
              author.room = room;
              return _this.receive(new TextMessage(author, message));
            });
          };
          connector.onMessage(function(channel, from, message) {
            var mention_name, regex;
            mention_name = connector.mention_name;
            regex = new RegExp("^@" + mention_name + "\\b", "i");
            message = message.replace(regex, "" + mention_name + ": ");
            return handleMessage({
              getAuthor: function() {
                return _this.robot.brain.userForName(from) || new User(from);
              },
              message: message,
              reply_to: channel,
              room: _this.roomNameFromJid(channel)
            });
          });
          connector.onPrivateMessage(function(from, message) {
            var mention_name, regex;
            mention_name = connector.mention_name;
            regex = new RegExp("^@?" + mention_name + "\\b", "i");
            message = "" + mention_name + ": " + (message.replace(regex, ""));
            return handleMessage({
              getAuthor: function() {
                return _this.robot.brain.userForId(_this.userIdFromJid(from));
              },
              message: message,
              reply_to: from
            });
          });
          changePresence = function(PresenceMessage, user_jid, room_jid, currentName) {
            return init.done(function() {
              var user;
              user = _this.robot.brain.userForId(_this.userIdFromJid(user_jid)) || {};
              if (user) {
                user.room = room_jid;
                if (currentName.length) {
                  user.name = currentName;
                }
                return _this.receive(new PresenceMessage(user));
              }
            });
          };
          connector.onEnter(function(user_jid, room_jid, currentName) {
            return changePresence(EnterMessage, user_jid, room_jid, currentName);
          });
          connector.onLeave(function(user_jid, room_jid) {
            return changePresence(LeaveMessage, user_jid, room_jid);
          });
          return connector.onInvite(function(room_jid, from_jid, message) {
            var action;
            action = _this.options.autojoin ? "joining" : "ignoring";
            _this.logger.info("Got invite to " + room_jid + " from " + from_jid + " - " + action);
            if (_this.options.autojoin) {
              return joinRoom(room_jid);
            }
          });
        };
      })(this));
      connector.connect();
      return this.connector = connector;
    };

    HipChat.prototype.userIdFromJid = function(jid) {
      var e;
      try {
        return jid.match(/^\d+_(\d+)@chat\./)[1];
      } catch (_error) {
        e = _error;
        return this.logger.error("Bad user JID: " + jid);
      }
    };

    HipChat.prototype.roomNameFromJid = function(jid) {
      var e;
      try {
        return jid.match(/^\d+_(.+)@conf\./)[1];
      } catch (_error) {
        e = _error;
        return this.logger.error("Bad room JID: " + jid);
      }
    };

    HipChat.prototype.get = function(path, callback) {
      return this.request("GET", path, null, callback);
    };

    HipChat.prototype.post = function(path, body, callback) {
      return this.request("POST", path, body, callback);
    };

    HipChat.prototype.request = function(method, path, body, callback) {
      var headers, host, options, request;
      this.logger.debug("Request:", method, path, body);
      host = this.options.host || "api.hipchat.com";
      headers = {
        "Host": host
      };
      if (!this.options.token) {
        return callback("No API token provided to Hubot", null);
      }
      options = {
        agent: false,
        host: host,
        port: 443,
        path: path += "?auth_token=" + this.options.token,
        method: method,
        headers: headers
      };
      if (method === "POST") {
        headers["Content-Type"] = "application/x-www-form-urlencoded";
        options.headers["Content-Length"] = body.length;
      }
      request = HTTPS.request(options, (function(_this) {
        return function(response) {
          var data;
          data = "";
          response.on("data", function(chunk) {
            return data += chunk;
          });
          response.on("end", function() {
            var err;
            if (response.statusCode >= 400) {
              _this.logger.error("HipChat API error: " + response.statusCode);
            }
            try {
              return callback(null, JSON.parse(data));
            } catch (_error) {
              err = _error;
              return callback(null, data || {});
            }
          });
          return response.on("error", function(err) {
            return callback(err, null);
          });
        };
      })(this));
      if (method === "POST") {
        request.end(body, "binary");
      } else {
        request.end();
      }
      return request.on("error", (function(_this) {
        return function(err) {
          _this.logger.error(err);
          if (err.stack) {
            _this.logger.error(err.stack);
          }
          return callback(err);
        };
      })(this));
    };

    return HipChat;

  })(Adapter);

  errmsg = function(err) {
    return err + (err.stack ? '\n' + err.stack : '');
  };

  exports.use = function(robot) {
    return new HipChat(robot);
  };

}).call(this);
